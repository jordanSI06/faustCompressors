/************************************************************************
 ************************************************************************
  	FAUST library file
	Copyright (C) 2016 Bart Brouns
    ---------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation; either version 2.1 of the
	License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
 	License along with the GNU C Library; if not, write to the Free
  	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  	02111-1307 USA.
 ************************************************************************
 ************************************************************************/

declare name "Sliding Reduce Library";
declare author "Bart Brouns (bart@magnetophon.nl)";
declare copyright "Bart Brouns";
declare version "0.1";
declare license "LGPL";

import("stdfaust.lib");

//---------------------------------------------------------------
// Provides various operations on the last N samples
// using a high order 'slidingReduce(op,N,maxN,disabledVal,x)' fold-like function :
//
//   slidingSumN(n,maxn) : the sliding sum of the last n input samples
//   slidingMaxN(n,maxn) : the sliding max of the last n input samples
//   slidingMinN(n,maxn) : the sliding min of the last n input samples
//   slidingMeanN(n,maxn) : the sliding mean of the last n input samples
//   slidingRMSn(n,maxn)  : the sliding RMS of the last n input samples
//---------------------------------------------------------------

//---------------------------------------------------------------
// slidingReduce(op,N,maxN,disabledVal,x)
//---------------------------------------------------------------

// Fold-like high order function. Apply a binary operation <op>
// on the last <n> consecutive samples of a signal <x>.
// For example : slidingReduce(max,128,128,-INFINITY) will compute the maximum of
// the last 128 samples.
// The output is updated each sample,
// unlike reduce, where the output is constant for the duration of a block.

// N           is the number of values to process
// maxN        is the maximum number of values to process
// op          is the operator
// disabledVal is the value to use when we want to ignore a value.

// In other words:
// op(x,disabledVal) should equal x
// For example:
// +(x,0) equals x
// min(x,INFINITY) equals x
// So if we want to calculate the sum, we need to give 0 as disabledVal,
// and if we want the minimum, we need to give INFINITY as disabledVal

//---------------------------------------------------------------
// working principle
//---------------------------------------------------------------

// Say we want the sum of the last 100 values.
// I will explain 3 methods to do that, each more complex but less expensive then the last.
// They build on each others ideas, so form a better followable train of thought.

// Method 1
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L84

// The simplest is to look up what the value is now, add it to the value of one sample ago,
// add that to the value two samples ago, and so forth.
// This costs one plus and one delayline for each value we want to sum.

// Method 2
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L92

// A more efficient method is based on the following idea:
// The sum of the last 10 values, let's call them v0 trough v-9, delayed by 10 samples,
// is equal to the sum of v-10 trough v-19.
// The sum of those two is equal to the sum of v0 trough v-19.

// So now we just need to calculate the sum of only 10 values (let's call it the block), add it to itself delayed by 10 samples,
// add that to the block delayed by 20 samples, etcetera.
// So adding 10 samples more, only costs one plus and one delay,
// on top of the operators to calculate the sum of the first ten.

// Method 3
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L130

// The next step is to take this idea to the extreme:
// We can calculat the sum of the last four values as the sum of the last two plus the sum of the last two delayed by 2.
// The sum of the last eight is the sum of the last four plus the sum of the last four delayed by four.
// And on until you reach 128.
// So now it only costs one plus and one delay to double the number of values we sum.

// Trouble is, we wanted a 100 values, not 128.
// Even better would be to choose at run time how many values to add.
// To explain how that's done, we will again look at each of the above three methods.

// To choose whether a value is used, we can multiply it by 1 or 0 after it has been delayed.
// So in the first method, if we want to have the sum of the last 42 values out of a maximum of 100,
// we multiply v0 through v-41 by 1 and v-42 trough v-99 by 0, and then add them all up.
// This costs one multiply for each extra value we want to switch,
// on top of the operations to do the non-switched version.

// In the second method, we need to multiply the blocks.
// So blocks 0 through -4 representing v0 trough -v39 get multiplied by 1,
// and block -5 trough -10, representing v-40 trough -99, get turned off.
// But thats only 40 values.
// To get the last two, we need to use a variable block:
// a block of up to 10 samples, where each sample can be turned on or of.
// To get the sum of v-40 and v-41, we take the sum of the last 2 (v0 and v1),
// using our variable block, and delay it by 40 samples.
// Add that to the sum of the first 40, and we have 42 again.
// This costs one multiply per 10 values, plus the 10 multiplies and single delay for the variable block.

// To switch on and off values in the third method is a bit tricky:
// With the second method, the normal (non variable) blocks have a fixed delaytime:
// Block 4 will only ever be used when blocks 1 trough 3 are allready on,
// so it always gets a delay of 30 samples.

// The problem with the 3rd method is that the blocks are not always used in the same order,
// So they need a variable delay:

// For 42 we need a block of 32, plus a block of 8, plus a block of 2.
// The block of 2 doesn't get delayed, so represents v0 and v-1,
// the block of 8 gets delayed by 2 so it represents v-2 trough v-9
// and the block of 32 gets delayed by 10, so represents v-10 trough v-41.
// Add them all up, and we have the sum of v0 trough v-41 again.

// To illustrate that a certain block does not always get the same delay:
// If we wanted to get the sum of the last 32 values,
// we'd also use the 32 block, but *not* delayed, so it would represent
// v0 trough v-31

// So for making the third method switchable,
// we only need one multiply and one delay for each doubling of the number of values.

// To generalize from a function that adds the last n values
// to one that does any(* note) two input operation on the last n values,
// we just need to replace the  'times 1' and 'times 0'
// by 'choose input value' and 'choose bypass value' respectively.
// And of course change out the plus operator for a placeholder.
// That is implemented in slidingReduce below.

// If you can not, or do not want to specify a 'bypass value', you can use newSlidingReduce below.

// (* note) Not actually any operation: there are a few assumtions in the algorithm, as explained above.

// todo: can we do it with one switched block less and an op(x) at the end?
// that way the first block represents 2 instead of 1.

//***************************************************************************************************************************************************************************
// new explanation
//***************************************************************************************************************************************************************************

// If we want the maximum of the last 4 values, we can do that as
simpleMax(x) =
  (
    (
      max(x@0,x@1),
      max(x@2,x@3)
    ) :max
  ),
  (
    (
      max(x@4,x@5),
      max(x@6,x@7)
    ) :max
  )
  :max;

// max(x@2,x@3)
//is the same as
//max(x@0,x@1)@2
// but the latter re-uses a value we already computed,so is more efficient.
// Using the same trick for values 4 trough 7, we can write:
efficientMax(x)=
  (
    (
      max(x@0,x@1),
      max(x@0,x@1)@2
    ) :max
  ),
  (
    (
      max(x@0,x@1),
      max(x@0,x@1)@2
    ) :max@4
  )
  :max;

// we can rewrite it recursively, so it becomes possible to get the maximum at have any number of values, as long as it's a power of 2.

recursiveMax =
  case {
    (1,x) => x;
    (N,x) =>  max(recursiveMax(N/2,x) , recursiveMax(N/2,x)@(N/2));
  };


// what if we want to look at a number of values that's not a power of 2?
// For each value, we will have to decide whether to use it or not.
// If N is bigger than the index of the value, we use it, otherwise we replace it with (0-INFINITY)

variableMax(N,x) =
  (
    (
      max
      (
        (x@0 : useVal(0)),
        (x@1 : useVal(1))
      ),
      max
      (
        (x@2 : useVal(2)),
        (x@3 : useVal(3))
      )
      :max
    ),
    (
      max
      (
        (x@4 : useVal(4)),
        (x@5 : useVal(5))
      ),
      max
      (
        (x@6 : useVal(6)),
        (x@7 : useVal(7))
      ):max
    )
  ):max
 with
 {
   useVal(i) = select2( (N>=i) , (0-INFINITY),_);
 };

// Now it becomes impossible to re-use any values.
// To fix that let's first look at how we'd implement it using recursiveMax, but with a fixed N that is not a power of 2.
// For example, this is how you'd do it with N=3

binaryMaxThree(x) =
  (
    recursiveMax(1,x)@0, // the first x
    recursiveMax(2,x)@1  // the second and third x
  ):max;

// N=6
binaryMaxSix(x) =
  (
    recursiveMax(2,x)@0, // first two
    recursiveMax(4,x)@2  // third trough sixt
  ):max;
// Note that recursiveMax(2,x) is used at a different delay then in binaryMaxThree, since it looks at 3 trough 6, not 2 and 3
// Each block is delayed the combined size of the previous blocks

// N=7
binaryMaxSeven(x) =
  (
    (
      recursiveMax(1,x)@0, // first x
      recursiveMax(2,x)@1  // second and third
    ):max
  ,
    (
      recursiveMax(4,x)@3  // fourth trough seventh
    )
  ):max;

// To make a variable version, we need to know which powers of two are used, and at which delay time.

// To know if a power of 2 is used we need to do binary counting.



// Then it becomes a matter of:
//- lining up all the different block sizes in parallel:  the first par() statement
//- delaying each the appropriate amount: sumOfPrevBlockSizes()
//- turning it on or off: useVal()
//- getting the maximum of all of them: combine()

// In faust, we can only do that for a fixed maximum number of values: maxN
variableBinaryMaxN(N,maxN,x) =
  par(i,maxNrBits,recursiveMax(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i) :useVal(i)):combine(maxNrBits) with {
  // apply <op> to the last <N> values of <x>, where <N> is fixed
  // The sum of all the sizes of the previous blocks
  sumOfPrevBlockSizes(N,maxN,0) = 0;
  sumOfPrevBlockSizes(N,maxN,i) = (ba.subseq((allBlockSizes(N,maxN)),0,i):>_);
  allBlockSizes(N,maxN) = par(i, maxNrBits, pow2(i) * isUsed(i) );
  maxNrBits = int2nrOfBits(maxN);
  // get the maximum of all blocks
  combine(2) = max;
  combine(N) = max(combine(N-1),_);
  // Decide wether or not to use a certain value, based on N
  useVal(i) = select2( isUsed(i), (0-INFINITY),_);
  isUsed(i) = ba.take(i+1,(int2bin(N,maxN)));
};

// ok, let's pick hese apart individually:

// the first par() statement
// maxNrBits determines the number of bits needed
//
// sumOfPrevBlockSizes()
//
// useVal()
// combine()

//***************************************************************************************************************************************************************************

slidingReduce(op,N,maxN,disabledVal,x) =
  // par(i,maxNrBits,fixedDelayOp(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i) :useVal(i)):combine(maxNrBits) with {
  par(i,maxNrBits,recursiveMax(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i) :useVal(i)):combine(maxNrBits) with {
  // apply <op> to the last <N> values of <x>, where <N> is fixed
  fixedDelayOp = case {
                   (1,x) => x;
                   (N,x) =>  op(fixedDelayOp(N/2,x) , fixedDelayOp(N/2,x)@(N/2));
                 };
  // The sum of all the sizes of the previous blocks
  sumOfPrevBlockSizes(N,maxN,0) = 0;
  sumOfPrevBlockSizes(N,maxN,i) = (ba.subseq((allBlockSizes(N,maxN)),0,i):>_);
  allBlockSizes(N,maxN) = par(i, maxNrBits, (pow2(i)) * isUsed(i) );
  maxNrBits = int2nrOfBits(maxN);
  // Apply <op> to <N> parallel inputsignals
  // combine(2) = op;
  // combine(N) = op(combine(N-1),_);
  combine(2) = max;
  combine(N) = max(combine(N-1),_);
  // Decide wether or not to use a certain value, based on N
  // Basically only the second <select2> is needed,
  // but this version also works for N == 0
  // 'works' in this case means 'does the same as reduce
  useVal(i) =
    _<:select2((i==0) & (N==0) ,
               select2( isUsed(i) , disabledVal,_),
               _
              );
  // useVal(i) =
  //     select2( isUsed(i) , disabledVal,_);
  isUsed(i) = ba.take(i+1,(int2bin(N,maxN)));
};

// If you can not, or do not want to specify a 'bypass value', you can use newSlidingReduce below.
newSlidingReduce(N,maxN,op,disabledVal,x) =
  par(i,maxNrBits,fixedDelayOp(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i) )
  :switched_combine(N,maxN)
with {
  // apply <op> to the last <N> values of <x>, where <N> is fixed
  fixedDelayOp = case {
                   (1,x) => x;
                   (N,x) =>  op(fixedDelayOp(N/2,x) , fixedDelayOp(N/2,x)@(N/2));
                 };
  // The sum of all the delays that are applied to the previous blocks
  sumOfPrevBlockSizes(N,maxN,0) = 0;
  sumOfPrevBlockSizes(N,maxN,i) = (ba.subseq((allBlockSizes(N,maxN)),0,i):>_) with {
    allBlockSizes(N,maxN) = par(j, maxNrBits, (pow2(j)) :useVal(j) );
  };
  // maxNrBits = int2nrOfBits(maxN);
  // Apply <op> to <N> parallel inputsignals
  combine(0) = 0:!;
               combine(1) = _;
  combine(2) = op;
  combine(N) = op(combine(N-1),_);

  isUsed(i,n) = int(floor(i/(pow2(n)))%2);

  nrOfUsedBits(i,n) = par(j,int2nrOfBits(n),isUsed(i,j)):>_;

  switched_combine(i,n) =
    si.bus(int2nrOfBits(n))<:
    par(j,n,
        par(k,int2nrOfBits(n),S(isUsed(j+1,k))):combine(nrOfUsedBits(j+1,n))
       )
    : par(j, n, _*(i==j+1)):>_
  with {
    S(0) = !;
           S(1) = _;
  };
  // isUsed(i) = ba.take(i+1,(int2bin(N,maxN)));
};

isSquare(N) =
  (sqrt(N)  == floor(sqrt(N)));
// N is a Fibonacci number if and only if 5 N^2 + 4 or 5 N^2 - 4 is a square number.
// http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#section5
isFibonacci(N) =
  isSquare((5*(pow(N,2)))+4)
  +
  isSquare((5*(pow(N,2)))-4);

fixedFibonacciOps(N,op,disabledVal,x) =
  (seq(i, N+1, fixedFibonacciOpPart(i)))
  // fixedFibonacciOpPart(1)
  // :(!,_)
with {
  fixedFibonacciOpPart(0) = disabledVal;
  fixedFibonacciOpPart(1) = _, x;
  fixedFibonacciOpPart(2) = _,_,x;
  fixedFibonacciOpPart(3) = si.bus(3),op(x,x');
  fixedFibonacciOpPart(n) =
    (si.bus(n-2),((split,split):ro.interleave(2,2)))
    :(si.bus(n),op(_@Fibonacci2int(n-1),_));
  split = _<:si.bus(2);
};

fixedFibonacciOp(0,op,disabledVal,x) = disabledVal;
fixedFibonacciOp(1,op,disabledVal,x) = x;
fixedFibonacciOp(2,op,disabledVal,x) = x;
fixedFibonacciOp(3,op,disabledVal,x) = op(x,x');
fixedFibonacciOp(N,op,disabledVal,x) =
  (x,disabledVal):(seq(i, N-2, fixedFibonacciOpPart(i+3))):(!,_)
with {
  fixedFibonacciOpPart(3,valMinOne,val) = x,op(x,x');
  fixedFibonacciOpPart(i,valMinOne,val) = val,op(val, valMinOne@Fibonacci2int(i-1));
};
// fixedFibonacciOp(0,op,disabledVal,x) = disabledVal;
// fixedFibonacciOp(1,op,disabledVal,x) = x;
// fixedFibonacciOp(2,op,disabledVal,x) = x;
// fixedFibonacciOp(i,op,disabledVal,x) = op(fixedFibonacciOp((i-1),op,disabledVal,x), fixedFibonacciOp((i-2),op,disabledVal,x)@Fibonacci2int(i-1));

FibonacciOp(0,op,disabledVal,x) = disabledVal;
FibonacciOp(1,op,disabledVal,x) = x;
FibonacciOp(N,op,disabledVal,x) =
  op( fixedFibonacciOp( largestIndex ,op,disabledVal,x) , (FibonacciOp (rest,op,disabledVal,x)@largestInt) )
with {
  largestIndex = int2FibonacciIndexOfLargestPart(N);
  largestInt = Fibonacci2int(largestIndex);
  rest = max(0, N-largestInt);
};
Phi =  (sqrt(5) +1)/2;
// int2FibonacciFloat(0) = 0;
// int2FibonacciFloat(1) = 1;
int2FibonacciFloat(N) =
  select2(N>0,0,
          select2(N>1,1,
                  (log(N) + (log(5)/2))/log(Phi))); // source: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#section6
int2FibonacciFloored(N) = int(floor(int2FibonacciFloat(N)));

// int2FibonacciIndexOfLargestPart(0) = 0;
int2FibonacciIndexOfLargestPart(N) = // int2fibonacci sometimes gives a sligthly too low value, so we test:
  select2((N == Fibonacci2int(int2FibonacciFloored(N+1))), int2FibonacciFloored(N),int2FibonacciFloored(N+1) )
; // more info: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#section6

// int2FibonacciIndexOfLargestPart(N) = // make a table.
// int2FibonacciIndexOfLargestPartCalc(time)

myBus(0)=0:!; // redefine si.bus so it can have 0 elements
myBus(n) = si.bus(n);

Fibonacci2intSeq(n,maxN) =
  // 1:seq(i, maxN-1 , int( _ * Phi ))

  0<:(_,_):seq(i, maxN-1 , myBus(i+1) , Fibonacci2intPart(i+1))
  : (si.bus(maxN),!)
  : (par(i, maxN, * (i==n)))
  // : ba.selector(1,maxN)
  :>_
with {
  // Fibonacci2intPart(0,prevFib)=0,(prevFib:!) <:(_,_);
  Fibonacci2intPart(1,prevFib)=1,(prevFib:!) <:(_,_);
  Fibonacci2intPart(2,prevFib)=1,(prevFib:!) <:(_,_);
  Fibonacci2intPart(n,prevFib) = ( prevFib * Phi ) : (_+0.5:floor) <:(_,_);    // for all n > 1
};

Fibonacci2intRecurive(0)=0;
Fibonacci2intRecurive(1)=1;
Fibonacci2intRecurive(N) = Fibonacci2intRecurive(N-1) + Fibonacci2intRecurive(N-2);

maxNrBits = 28;
// maxNrBits = 4;
// maxNrBits = 19;
// works fine up to about 21 maxNrBits, but then eats all RAM trying to compile:
// Fibonacci2int(N) = par(i,maxNrBits+1, Fibonacci2intRecurive(i)*(N==i)):>_;
// so we do:
time 		= int((+(1)~_ ) - 1); 			// 0,1,2,3,...
// Fibonacci2int(i) = rdtable(maxNrBits+1, par(j,maxNrBits+1, Fibonacci2intRecurive(j)*(j==(int(time)))):>_, i:min(maxNrBits+1):max(0));
Fibonacci2int(i) = rdtable(maxNrBits+1, Fibonacci2intSeq(time,maxNrBits+1), i:min(maxNrBits+1):max(0));

OLDfibReduce(N,maxN,op,disabledVal,x) =
  (N,disabledVal,0):seq(i,maxNrBits+1, fibPart(i) ):(!,_,!)
with {
  // i=3;
  isUsed(i,n) = (int2FibonacciIndexOfLargestPart(n)) == i;
  fibPart(i,rest,intermediateVal,sumOfDelays) =
    (max(0, rest-(isUsed((currentBit(i)),rest) * ( Fibonacci2int(largestIndex(Fibonacci2int(currentBit(i)))) )))),
    op(intermediateVal, (select2( isUsed((currentBit(i)),rest ), disabledVal, (fixedFibonacciOp( (currentBit(i)) , op,disabledVal,x)@sumOfDelays)))),
    (sumOfDelays+ (isUsed(currentBit(i),rest ) * largestInt(rest)));
  currentBit(i) = (maxNrBits-i);
  // maxNrBits = int2FibonacciIndexOfLargestPart(maxN)+1;
  largestIndex(n) = int2FibonacciIndexOfLargestPart(n);
  largestInt(n) = Fibonacci2int(largestIndex(n));
};

fibReduce(N,maxN,op,disabledVal,x) =
  (
    disabledVal,N,0,
    (fixedFibonacciOps(maxNrBits,op,disabledVal,x):ro.cross(maxNrBits+1))
  )
  :seq(i,maxNrBits+1, fibPart(i) ):(_,!,!)
with {
  // i=3;
  isUsed(i,n) = (int2FibonacciIndexOfLargestPart(n)) == i;
  fibPart(i,intermediateVal,rest,sumOfDelays) =
    op(intermediateVal, (select2( isUsed((currentBit(i)),rest ), disabledVal, (_@sumOfDelays)))),
    (max(0, rest-(isUsed((currentBit(i)),rest) * ( Fibonacci2int(largestIndex(Fibonacci2int(currentBit(i)))) )))),
    (sumOfDelays+ (isUsed(currentBit(i),rest ) * largestInt(rest))),
    myBus(maxNrBits-i);
  currentBit(i) = (maxNrBits-i);
  // maxNrBits = int2FibonacciIndexOfLargestPart(maxN)+1;
  largestIndex(n) = int2FibonacciIndexOfLargestPart(n);
  largestInt(n) = Fibonacci2int(largestIndex(n));
};

FibonacciSlidingReduce(N,maxN,op,disabledVal,x) =
  par(i,maxNrBits,fixedFibonacciOp(i)@sumOfPrevBlockSizes(N,maxN,i) :useVal(i)):combine(maxNrBits) with {
  // The sum of all the delays that are applied to the previous blocks
  sumOfPrevBlockSizes(N,maxN,0) = 0;
  sumOfPrevBlockSizes(N,maxN,i) = (ba.subseq((allBlockSizes(N,maxN)),0,i):>_) with {
    allBlockSizes(N,maxN) = par(j, maxNrBits, j :useVal(j) );
  };
  // maxNrBits = int2FibonacciIndexOfLargestPart(maxN)+1;
  // Apply <op> to <N> parallel inputsignals
  combine(2) = op;
  combine(N) = op(combine(N-1),_);
  // Decide wether or not to use a certain value, based on N
  // Basically only the second <select2> is needed,
  // but this version also works for N == 0
  // 'works' in this case means 'does the same as reduce
  useVal(j) =
    _<:select2((j==0) & (N==0) ,
               select2( isUsed(j) , disabledVal,_),
               _
              );
  // useVal(i) =
  //     select2( isUsed(i) , disabledVal,_);
  isUsed(i) = ba.take(i+1,(int2bin(N,maxN)));
  };

// pow2(i) = 1<<i;
// same as:
pow2(i) = int(pow(2,i));
// but in the block diagram, it will be displayed as a number, instead of a formula

// // convert N into a list of ones and zeros
int2bin(N,maxN) = par(j,int2nrOfBits(maxN),int(floor(N/(pow2(j))))%2);
// calculate how many ones and zeros are needed to represent maxN
int2nrOfBits(0) = 0;
int2nrOfBits(maxN) = int(floor(log(maxN)/log(2))+1);

// slidingSumN(n,maxn) : the sliding sum of the last n input samples
slidingSumN(n,maxn) = slidingReduce(+,n,maxn,0);

// slidingMaxN(n,maxn) : the sliding max of the last n input samples
slidingMaxN(n,maxn) = slidingReduce(max,n,maxn,-INFINITY);

// slidingMinN(n,maxn) : the sliding min of the last n input samples
slidingMinN(n,maxn) = slidingReduce(min,n,maxn,INFINITY);

// slidingMeanN(n,maxn) : the sliding mean of the last n input samples
slidingMeanN(n,maxn) = slidingSumN(n,maxn)/n;

// slidingRMSn(n,maxn)  : the sliding RMS of the last n input samples
slidingRMSn(n,maxn) = pow(2):slidingMeanN(n,maxn) : sqrt;

// maybe useful for math.lib:

INFINITY = fconstant(float INFINITY, <math.h>);

// bug in ba.subseq?:
// no elements is undefined.
// proposed solution:
// ba.subseq((head, tail), 0, 0)      = !;
// ba.subseq((head, tail), 0, 1)      = head;
// ba.subseq((head, tail), 0, n)      = head, ba.subseq(tail, 0, n-1);
// ba.subseq((head, tail), p, n)      = ba.subseq(tail, p-1, n);
// ba.subseq(head, 0, n)              = head;
