/************************************************************************
 ************************************************************************
  	FAUST library file
	Copyright (C) 2016 Bart Brouns
    ---------------------------------------------------------------------
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
	published by the Free Software Foundation; either version 2.1 of the
	License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
 	License along with the GNU C Library; if not, write to the Free
  	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
  	02111-1307 USA.
 ************************************************************************
 ************************************************************************/

declare name "Sliding Reduce Library";
declare author "Bart Brouns (bart@magnetophon.nl)";
declare copyright "Bart Brouns";
declare version "0.1";
declare license "LGPL";


//---------------------------------------------------------------
// Provides various operations on the last N samples
// using a high order 'slidingReduce(N,maxN,op,disabledVal,x)' fold-like function :
//
//   slidingSumN(n,maxn) : the sliding sum of the last n input samples
//   slidingMaxN(n,maxn) : the sliding max of the last n input samples
//   slidingMinN(n,maxn) : the sliding min of the last n input samples
//   slidingMeanN(n,maxn) : the sliding mean of the last n input samples
//   slidingRMSn(n,maxn)  : the sliding RMS of the last n input samples
//---------------------------------------------------------------



//---------------------------------------------------------------
// slidingReduce(N,maxN,op,disabledVal,x)
//---------------------------------------------------------------

// Fold-like high order function. Apply a binary operation <op>
// on the last <n> consecutive samples of a signal <x>.
// For example : slidingReduce(128,128,max,-INFINITY) will compute the maximun of
// the last 128 samples.
// The output is updated each sample,
// unlike reduce, where the output is constant for the duration of a block.

// N           is the number of values to process
// maxN        is the maximum number of values to process
// op          is the operator
// disabledVal is the value to use when we want to ignore a value.

// In other words:
// op(x,disabledVal) should equal x
// For example:
// +(x,0) equals x
// min(x,INFINITY) equals x
// So if we want to calculate the sum, we need to give 0 as disabledVal,
// and if we want the minimum, we need to give INFINITY as disabledVal

//---------------------------------------------------------------
// working principle
//---------------------------------------------------------------

// Say we want the sum of the last 100 values.
// I will explain 3 methods to do that, each more complex but less expensive then the last.
// They build on each others ideas, so form a better followable train of thought.

// Method 1
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L84

// The simplest is to look up what the value is now, add it to the value of one sample ago,
// add that to the value two samples ago, and so forth.
// This costs one plus and one delayline for each value we want to sum.

// Method 2
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L92

// A more efficient method is based on the following idea:
// The sum of the last 10 values, let's call them v0 trough v-9, delayed by 10 samples,
// is equal to the sum of v-10 trough v-19.
// The sum of those two is equal to the sum of v0 trough v-19.

// So now we just need to calculate the sum of only 10 values (let's call it the block), add it to itself delayed by 10 samples,
// add that to the block delayed by 20 samples, etcetera.
// So adding 10 samples more, only costs one plus and one delay,
// on top of the operators to calculate the sum of the first ten.

// Method 3
// implemented in:
// https://github.com/magnetophon/faustCompressors/blob/master/compressors.lib#L130

// The next step is to take this idea to the extreme:
// We can calculat the sum of the last four values as the sum of the last two plus the sum of the last two delayed by 2.
// The sum of the last eight is the sum of the last four plus the sum of the last four delayed by four.
// And on until you reach 128.
// So now it only costs one plus and one delay to double the number of values we sum.

// Trouble is, we wanted a 100 values, not 128.
// Even better would be to choose at run time how many values to add.
// To explain how that's done, we will again look at each of the above three methods.

// To choose whether a value is used, we can multiply it by 1 or 0 after it has been delayed.
// So in the first method, if we want to have the sum of the last 42 values out of a maximum of 100,
// we multiply v0 through v-41 by 1 and v-42 trough v-99 by 0, and then add them all up.
// This costs one multiply for each extra value we want to switch,
// on top of the operations to do the non-switched version.

// In the second method, we need to multiply the blocks.
// So blocks 0 through -4 representing v0 trough -v39 get multiplied by 1,
// and block -5 trough -10, representing v-40 trough -99, get turned off.
// But thats only 40 values.
// To get the last two, we need to use a variable block:
// a block of up to 10 samples, where each sample can be turned on or of.
// To get the sum of v-40 and v-41, we take the sum of the last 2 (v0 and v1),
// using our variable block, and delay it by 40 samples.
// Add that to the sum of the first 40, and we have 42 again.
// This costs one multiply per 10 values, plus the 10 multiplies and single delay for the variable block.

// To switch on and off values in the third method is a bit tricky:
// With the second method, the normal (non variable) blocks have a fixed delaytime:
// Block 4 will only ever be used when blocks 1 trough 3 are allready on,
// so it always gets a delay of 30 samples.

// The problem with the 3rd method is that the blocks are not always used in the same order,
// So they need a variable delay:

// For 42 we need a block of 32, plus a block of 8, plus a block of 2.
// The block of 2 doesn't get delayed, so represents v0 and v-1,
// the block of 8 gets delayed by 2 so it represents v-2 trough v-9
// and the block of 32 gets delayed by 10, so represents v-10 trough v-41.
// Add them all up, and we have the sum of v0 trough v-41 again.

// To illustrate that a certain block does not always get the same delay:
// If we wanted to get the sum of the last 32 values,
// we'd also use the 32 block, but *not* delayed, so it would represent
// v0 trough v-31

// So for making the third method switchable,
// we only need one multiply and one delay for each doubling of the number of values.

// To generalize from a function that adds the last n values
// to one that does any(* note) two input operation on the last n values,
// we just need to replace the  'times 1' and 'times 0'
// by 'choose input value' and 'choose bypass value' respectively.
// And of course change out the plus operator for a placeholder.
// That is implemented in slidingReduce below.

// If you can not, or do not want to specify a 'bypass value', you can use newSlidingReduce below.

// (* note) Not actually any operation: there are a few assumtions in the algorithm, as explained above.


// todo: can we do it with one switched block less and an op(x) at the end?
// that way the first block represents 2 instead of 1.
slidingReduce(N,maxN,op,disabledVal,x) =
par(i,maxNrBits,fixedDelayOp(1<<i,x)@sumOfPrevDelays(N,maxN,i) :useVal(i)):combine(maxNrBits) with {
// apply <op> to the last <N> values of <x>, where <N> is fixed
  fixedDelayOp = case {
    (1,x) => x;
    (N,x) =>  op(fixedDelayOp(N/2,x) , fixedDelayOp(N/2,x)@(N/2));
  };
  // The sum of all the delays that are applied to the previous blocks
  sumOfPrevDelays(N,maxN,0) = 0;
  sumOfPrevDelays(N,maxN,i) = (subseq((allDelays(N,maxN)),0,i):>_) with {
    allDelays(N,maxN) = par(j, maxNrBits, (1<<j) *  take(j+1,(int2bin(N,maxN))) );
  };
  maxNrBits = int2nrOfBits(maxN);
  // Apply <op> to <N> parallel inputsignals
  combine(2) = op;
  combine(N) = op(combine(N-1),_);
  // Decide wether or not to use a certain value, based on N
  // Basically only the second <select2> is needed,
  // but this version also works for N == 0
  // 'works' in this case means 'does the same as reduce
  useVal(i) =
    _<:select2((i==0) & (N==0) ,
      select2( take(i+1,(int2bin(N,maxN))) , disabledVal,_),
      _
    );
  // useVal(i) =
  //     select2( take(i+1,(int2bin(N,maxN))) , disabledVal,_);
};

newSlidingReduce(N,maxN,op,disabledVal,x) =
par(i,maxNrBits,fixedDelayOp(1<<i,x)@sumOfPrevDelays(N,maxN,i) )
:switched_combine(N,maxN)
with {
// apply <op> to the last <N> values of <x>, where <N> is fixed
  fixedDelayOp = case {
    (1,x) => x;
    (N,x) =>  op(fixedDelayOp(N/2,x) , fixedDelayOp(N/2,x)@(N/2));
  };
  // The sum of all the delays that are applied to the previous blocks
  sumOfPrevDelays(N,maxN,0) = 0;
  sumOfPrevDelays(N,maxN,i) = (subseq((allDelays(N,maxN)),0,i):>_) with {
    allDelays(N,maxN) = par(j, maxNrBits, (1<<j) *  take(j+1,(int2bin(N,maxN))) );
  };
  maxNrBits = int2nrOfBits(maxN);
  // Apply <op> to <N> parallel inputsignals
  combine(0) = 0:!;
  combine(1) = _;
  combine(2) = op;
  combine(N) = op(combine(N-1),_);

  isUsed(i,n) = int(floor(i/(1<<n))%2);

  nrOfUsedBits(i,n) = par(j,int2nrOfBits(n),isUsed(i,j)):>_;

  switched_combine(i,n) =
    bus(int2nrOfBits(n))<:
      par(j,n,
        par(k,int2nrOfBits(n),S(isUsed(j+1,k))):combine(nrOfUsedBits(j+1,n))
      )
      : par(j, n, _*(i==j+1)):>_
  with {
    S(0) = !;
    S(1) = _;
  };
};

// // convert N into a list of ones and zeros
int2bin(N,maxN) = par(i,int2nrOfBits(maxN),int(floor(N/(1<<i)))%2);
// calculate how many ones and zeros are needed to represent maxN
int2nrOfBits(0) = 0;
int2nrOfBits(maxN) = int(floor(log(maxN)/log(2))+1);


// slidingSumN(n,maxn) : the sliding sum of the last n input samples
slidingSumN(n,maxn) = slidingReduce(n,maxn,+,0);

// slidingMaxN(n,maxn) : the sliding max of the last n input samples
slidingMaxN(n,maxn) = slidingReduce(n,maxn,max,-INFINITY);

// slidingMinN(n,maxn) : the sliding min of the last n input samples
slidingMinN(n,maxn) = slidingReduce(n,maxn,min,INFINITY);

// slidingMeanN(n,maxn) : the sliding mean of the last n input samples
slidingMeanN(n,maxn) = slidingSumN(n,maxn)/n;

// slidingRMSn(n,maxn)  : the sliding RMS of the last n input samples
slidingRMSn(n,maxn) = pow(2):slidingMean(n,maxn) : sqrt;



// maybe useful for math.lib:

INFINITY = fconstant(float INFINITY, <math.h>);

// bug in subseq?:
// no elements is undefined.
// proposed solution:
// subseq((head, tail), 0, 0)      = !;
// subseq((head, tail), 0, 1)      = head;
// subseq((head, tail), 0, n)      = head, subseq(tail, 0, n-1);
// subseq((head, tail), p, n)      = subseq(tail, p-1, n);
// subseq(head, 0, n)              = head;
